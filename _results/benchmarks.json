{
    "benchmarks.TimeSuite.time_additive_multi_model_source": {
        "code": "class TimeSuite:\n    def time_additive_multi_model_source(self):\n        \"\"\"Time the creation and query of an AdditiveMultiObjectModel.\"\"\"\n        source1 = ConstantSEDModel(brightness=100.0, node_label=\"my_constant_sed_model\")\n        source2 = StepModel(brightness=50.0, t0=1.0, t1=2.0, node_label=\"my_step_model\")\n        model = AdditiveMultiObjectModel([source1, source2], node_label=\"my_multi_obj_model\")\n    \n        num_samples = 1000\n        state = model.sample_parameters(num_samples=num_samples)\n    \n        times = np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n        wavelengths = np.array([1000.0, 2000.0, 3000.0, 4000.0])\n        _ = model.evaluate_sed(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_additive_multi_model_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4f6134760c701b3e4de853ae44310094bad92838691e09b28d3151ccd6d8739f",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_apply_passbands": {
        "code": "class TimeSuite:\n    def time_apply_passbands(self):\n        \"\"\"Time applying the (already loaded) passbands to flux.\"\"\"\n        _ = self.passbands.fluxes_to_bandfluxes(self.fluxes)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_apply_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "86788dfd46a9ed4f77dee9cb389331f05530457bba54318a3c63e24089d7e064",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_apply_white_noise": {
        "code": "class TimeSuite:\n    def time_apply_white_noise(self):\n        \"\"\"Time the application of white noise to a sample.\"\"\"\n        _ = self.white_noise.apply(self.fluxes, white_noise_sigma=0.1)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_apply_white_noise",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cededfe2a93d1ec2df195eb162f9c73fc0da3267e51e257d1051ba7884bf8646",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_chained_evaluate_sed": {
        "code": "class TimeSuite:\n    def time_chained_evaluate_sed(self):\n        \"\"\"Time the generation of random numbers with an numpy generation node.\"\"\"\n    \n        def _add_func(a, b):\n            return a + b\n    \n        # Generate a starting mean and scale from uniform distributions. Use those to\n        # generate a sample from the normal distribution. Then shift that sample by -5.0.\n        loc_node = NumpyRandomFunc(\"uniform\", low=10.0, high=20.0)\n        scale_node = NumpyRandomFunc(\"uniform\", low=0.5, high=1.0)\n        norm_node = NumpyRandomFunc(\"normal\", loc=loc_node, scale=scale_node)\n        val_node = FunctionNode(_add_func, a=norm_node, b=-5.0)\n    \n        # Generate 100,000 samples.\n        _ = val_node.sample_parameters(num_samples=100_000)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_chained_evaluate_sed",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "80c7d3a61be57c5a5b13fe70b729edd7d20263c5ba9eda56c7ae1649924bee6b",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_salt3_model": {
        "code": "class TimeSuite:\n    def time_evaluate_salt3_model(self):\n        \"\"\"Time querying a predefined salt3 model.\"\"\"\n        _ = self.salt3_model.evaluate_sed(\n            self.times,\n            self.wavelengths,\n            graph_state=self.graph_state,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_salt3_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0f8a7d916403e16d4d9377aab2877a8f2eb7a85e90b7ea5fc3c19175bf060f2b",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_salt3_passbands": {
        "code": "class TimeSuite:\n    def time_evaluate_salt3_passbands(self):\n        \"\"\"Time evaluate the SALT3 model at the passband level.\"\"\"\n        _ = self.salt3_model.evaluate_bandfluxes(\n            self.passbands,\n            self.times,\n            self.filters,\n            self.graph_state,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_salt3_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "81b569e531e4d18debaf9b8c27e57a1b8743234df33bc4fa07fa8b12c1aad366",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_simple_linear_wavelength_model": {
        "code": "class TimeSuite:\n    def time_evaluate_simple_linear_wavelength_model(self):\n        \"\"\"Time evaluating a simple LinearWavelengthModel.\"\"\"\n        _ = self.linear_source.evaluate_sed(self.times, self.wavelengths)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_simple_linear_wavelength_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b2d35d9427af6a6f84f9df2cf239450820a0a26398de1fbbda57778b5f5e2f58",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_fnu_to_flam": {
        "code": "class TimeSuite:\n    def time_fnu_to_flam(self):\n        \"\"\"Time the fnu_to_flam function.\"\"\"\n        _ = fnu_to_flam(\n            self.fluxes,\n            self.wavelengths,\n            wave_unit=u.AA,\n            flam_unit=u.erg / u.second / u.cm**2 / u.AA,\n            fnu_unit=u.nJy,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_fnu_to_flam",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "83da8b3715faa7e37b2f3d19ad9cc48a5c54d8571f5969c09e7396aebf814e94",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_lightcurve_source": {
        "code": "class TimeSuite:\n    def time_lightcurve_source(self):\n        \"\"\"Time the creation and query of a LightcurveTemplateModel.\"\"\"\n        lc_times = np.linspace(0.0, 6 * np.pi, 100)\n        g_gluxes = np.sin(lc_times) + 3.0\n        r_gluxes = np.cos(lc_times) + 5.0\n    \n        lightcurves = {\n            \"g\": np.column_stack((lc_times, g_gluxes)),\n            \"r\": np.column_stack((lc_times, r_gluxes)),\n        }\n        lc_source = LightcurveTemplateModel(\n            lightcurves,\n            self.passbands,\n            lc_data_t0=0.0,\n            periodic=True,\n            baseline=None,\n            t0=0.0,\n        )\n    \n        # Sample the light curve source to ensure it works.\n        graph_state = lc_source.sample_parameters(num_samples=100)\n        _ = lc_source.evaluate_bandfluxes(\n            self.passbands,\n            self.times,\n            [\"r\" for _ in range(len(self.times))],\n            graph_state,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_lightcurve_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3a3bd425866241e807a4ddc5ac1215cb221428c83af0f99df6325cb6fe372100",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_load_passbands": {
        "code": "class TimeSuite:\n    def time_load_passbands(self):\n        \"\"\"Time loading the passbands from files.\"\"\"\n        _ = _load_test_passbands()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_load_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "edca995cbc28bffe05864cdbf2d92a031cd6a7c2e0347ea3017ebe3d5179ed88",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_and_evaluate_static_sed": {
        "code": "class TimeSuite:\n    def time_make_and_evaluate_static_sed(self):\n        \"\"\"Time the creation and evaluation of a static SED model.\"\"\"\n        sed = np.array(\n            [\n                [50.0, 100.0, 200.0, 300.0, 400.0, 500.0, 600.0],  # Wavelengths\n                [5.0, 10.0, 20.0, 20.0, 10.0, 5.0, 1.0],  # fluxes\n            ]\n        )\n        model = StaticSEDModel(sed, node_label=\"test\")\n        states = model.sample_parameters(num_samples=1000)\n    \n        times = np.array([1, 2, 3, 10, 20])\n        wavelengths = np.array([50.0, 100.0, 150.0, 200.0, 250.0, 300.0, 350.0, 400.0, 450.0])\n    \n        _ = model.evaluate_sed(times, wavelengths, states)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_and_evaluate_static_sed",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4a5aaf8eb3e9c64903b73cb2a1dc8649c61e8493c76f6515ddf1d806de7fc441",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_and_evaluate_step_model": {
        "code": "class TimeSuite:\n    def time_make_and_evaluate_step_model(self):\n        \"\"\"Time creating and evaluating a StepModel.\"\"\"\n        model = StepModel(brightness=100.0, t0=2.0, t1=5.0)\n        state = model.sample_parameters()\n        times = np.arange(0.0, 10.0, 0.05)\n        wavelengths = np.arange(1000.0, 2000.0, 5.0)\n        _ = model.evaluate_sed(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_and_evaluate_step_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "abad6817b74136264e4f1e5c612d373cc9ed1afeec33daffad53fc113f58e4f7",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_evaluate_constant_sed_model": {
        "code": "class TimeSuite:\n    def time_make_evaluate_constant_sed_model(self):\n        \"\"\"Time creating and querying a constant SEC model model.\"\"\"\n        source1 = ConstantSEDModel(brightness=100.0, node_label=\"my_constant_sed_model\")\n        state = source1.sample_parameters(num_samples=1000)\n    \n        times = np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n        wavelengths = np.array([1000.0, 2000.0, 3000.0, 4000.0])\n        _ = source1.evaluate_sed(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_evaluate_constant_sed_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4d5554c8a2cea40e76707cd14d9baa6d32c30afa4c9d5116730e393d612bdb12",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_new_salt3_model": {
        "code": "class TimeSuite:\n    def time_make_new_salt3_model(self):\n        \"\"\"Time creating a new SALT3 model.\"\"\"\n        _ = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_new_salt3_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2bdbf4d81441380c0bb0418fcb60a42bf6d12fcfbd0c971ccdd855327f2c8965",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_simple_linear_wavelength_model": {
        "code": "class TimeSuite:\n    def time_make_simple_linear_wavelength_model(self):\n        \"\"\"Time creating a simple LinearWavelengthModel.\"\"\"\n        _ = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_simple_linear_wavelength_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2c0d6e44b7dab19a5e6749cbf6e29fbf55cb939a0fe3c0089c3957bf63e4112b",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_x1_from_hostmass": {
        "code": "class TimeSuite:\n    def time_make_x1_from_hostmass(self):\n        \"\"\"Time the creation of the X1 function.\"\"\"\n        _ = HostmassX1Func(self.hostmass)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_x1_from_hostmass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "993c51fe5f9fb5a38111c3ca376d72167a12cd6a9fefc18f2bcafe492a9130ef",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_sample_x0_from_distmod": {
        "code": "class TimeSuite:\n    def time_sample_x0_from_distmod(self):\n        \"\"\"Time the computation of the X0 function.\"\"\"\n        _ = self.x0_func.sample_parameters()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_sample_x0_from_distmod",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c4cbd9543464b8f7dae93abbf98d3084e560359f8dec1c1ce13d93247dc20d29",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_sample_x1_from_hostmass": {
        "code": "class TimeSuite:\n    def time_sample_x1_from_hostmass(self):\n        \"\"\"Time the computation of the X1 function.\"\"\"\n        _ = self.x1_func.sample_parameters()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthModel that we can use in tests.\n        self.linear_source = LinearWavelengthModel(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate_sed(\n            self.times, self.wavelengths, graph_state=self.graph_state\n        )\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_sample_x1_from_hostmass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0d70f3b17ea281919c3a47af9a93a06c2cd2e7d0c0ab24da8f184e693f064667",
        "warmup_time": -1
    },
    "version": 2
}