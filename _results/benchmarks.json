{
    "benchmarks.TimeSuite.time_additive_multi_model_source": {
        "code": "class TimeSuite:\n    def time_additive_multi_model_source(self):\n        \"\"\"Time the creation and query of an AdditiveMultiSourceModel.\"\"\"\n        source1 = StaticSource(brightness=100.0, node_label=\"my_static_source\")\n        source2 = StepSource(brightness=50.0, t0=1.0, t1=2.0, node_label=\"my_step_source\")\n        model = AdditiveMultiSourceModel([source1, source2], node_label=\"my_multi_source\")\n    \n        num_samples = 1000\n        state = model.sample_parameters(num_samples=num_samples)\n    \n        times = np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n        wavelengths = np.array([1000.0, 2000.0, 3000.0, 4000.0])\n        _ = model.evaluate(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_additive_multi_model_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9c9eb71e51874e28e3feafbf45d6bc7e87e3bc2db579e0061f2e1cb53a3496f1",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_apply_passbands": {
        "code": "class TimeSuite:\n    def time_apply_passbands(self):\n        \"\"\"Time applying the (already loaded) passbands to flux.\"\"\"\n        _ = self.passbands.fluxes_to_bandfluxes(self.fluxes)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_apply_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "45223f368ec475765837653e76e05b372a81eda4226e02475d4b158ecb2de257",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_apply_white_noise": {
        "code": "class TimeSuite:\n    def time_apply_white_noise(self):\n        \"\"\"Time the application of white noise to a sample.\"\"\"\n        _ = self.white_noise.apply(self.fluxes, white_noise_sigma=0.1)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_apply_white_noise",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a6995db098074f873fabbb596ce5669f4d3dcd30cece21dcac253fb37030a868",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_chained_evaluate": {
        "code": "class TimeSuite:\n    def time_chained_evaluate(self):\n        \"\"\"Time the generation of random numbers with an numpy generation node.\"\"\"\n    \n        def _add_func(a, b):\n            return a + b\n    \n        # Generate a starting mean and scale from uniform distributions. Use those to\n        # generate a sample from the normal distribution. Then shift that sample by -5.0.\n        loc_node = NumpyRandomFunc(\"uniform\", low=10.0, high=20.0)\n        scale_node = NumpyRandomFunc(\"uniform\", low=0.5, high=1.0)\n        norm_node = NumpyRandomFunc(\"normal\", loc=loc_node, scale=scale_node)\n        val_node = FunctionNode(_add_func, a=norm_node, b=-5.0)\n    \n        # Generate 100,000 samples.\n        _ = val_node.sample_parameters(num_samples=100_000)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_chained_evaluate",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ffeec86b5afeff833f77437ee254e6f1282688647c4543cedabfae027f840bc0",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_salt3_model": {
        "code": "class TimeSuite:\n    def time_evaluate_salt3_model(self):\n        \"\"\"Time querying a predefined salt3 model.\"\"\"\n        _ = self.salt3_model.evaluate(\n            self.times,\n            self.wavelengths,\n            graph_state=self.graph_state,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_salt3_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a3d12a79138f69da17554800e2cd6b82a83aaf26c02fc490172d3ca49553c295",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_salt3_passbands": {
        "code": "class TimeSuite:\n    def time_evaluate_salt3_passbands(self):\n        \"\"\"Time evaluate the SALT3 model at the passband level.\"\"\"\n        _ = self.salt3_model.get_band_fluxes(\n            self.passbands,\n            self.times,\n            self.filters,\n            self.graph_state,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_salt3_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2b9eb8e1257ceac55367735cd155f33c8233fdedd48cba68333a378e12e641b6",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_evaluate_simple_linear_wavelength_source": {
        "code": "class TimeSuite:\n    def time_evaluate_simple_linear_wavelength_source(self):\n        \"\"\"Time evaluating a simple LinearWavelengthSource.\"\"\"\n        _ = self.linear_source.evaluate(self.times, self.wavelengths)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_evaluate_simple_linear_wavelength_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cb03c2216c91c611f26f225654c6814de1f4fd6f8218bcf14c3bfb88e42dd828",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_fnu_to_flam": {
        "code": "class TimeSuite:\n    def time_fnu_to_flam(self):\n        \"\"\"Time the fnu_to_flam function.\"\"\"\n        _ = fnu_to_flam(\n            self.fluxes,\n            self.wavelengths,\n            wave_unit=u.AA,\n            flam_unit=u.erg / u.second / u.cm**2 / u.AA,\n            fnu_unit=u.nJy,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_fnu_to_flam",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c76579b1b49673cd4fb49839025a865b178863d370877232433cd0552534a403",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_lightcurve_source": {
        "code": "class TimeSuite:\n    def time_lightcurve_source(self):\n        \"\"\"Time the creation and query of a LightcurveSource.\"\"\"\n        lc_times = np.linspace(0.0, 6 * np.pi, 100)\n        g_gluxes = np.sin(lc_times) + 3.0\n        r_gluxes = np.cos(lc_times) + 5.0\n    \n        lightcurves = {\n            \"g\": np.column_stack((lc_times, g_gluxes)),\n            \"r\": np.column_stack((lc_times, r_gluxes)),\n        }\n        lc_source = LightcurveSource(\n            lightcurves,\n            self.passbands,\n            lc_t0=0.0,\n            periodic=True,\n            baseline=None,\n            t0=0.0,\n        )\n    \n        # Sample the lightcurve source to ensure it works.\n        _ = lc_source.evaluate(self.times, self.wavelengths)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_lightcurve_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cecccd72c05f389a612cc8ca01c7c8f6975ab0df5d505a7be9c026ad5514f3ef",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_load_passbands": {
        "code": "class TimeSuite:\n    def time_load_passbands(self):\n        \"\"\"Time loading the passbands from files.\"\"\"\n        _ = _load_test_passbands()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_load_passbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c17cc83f9bce8c4818297b6ff1e23116ab684285946b2cbafc27f04f1e535482",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_and_evaluate_static_sed": {
        "code": "class TimeSuite:\n    def time_make_and_evaluate_static_sed(self):\n        \"\"\"Time the creation and evaluation of a static SED source model.\"\"\"\n        sed = np.array(\n            [\n                [50.0, 100.0, 200.0, 300.0, 400.0, 500.0, 600.0],  # Wavelengths\n                [5.0, 10.0, 20.0, 20.0, 10.0, 5.0, 1.0],  # fluxes\n            ]\n        )\n        model = StaticSEDSource(sed, node_label=\"test\")\n        states = model.sample_parameters(num_samples=1000)\n    \n        times = np.array([1, 2, 3, 10, 20])\n        wavelengths = np.array([50.0, 100.0, 150.0, 200.0, 250.0, 300.0, 350.0, 400.0, 450.0])\n    \n        _ = model.evaluate(times, wavelengths, states)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_and_evaluate_static_sed",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "897be4f5623b142e41eaa6a2630d3fbcc0877a9869850343e51aac06247f93b6",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_and_evaluate_step_source": {
        "code": "class TimeSuite:\n    def time_make_and_evaluate_step_source(self):\n        \"\"\"Time creating and evaluating a StepSource.\"\"\"\n        model = StepSource(brightness=100.0, t0=2.0, t1=5.0)\n        state = model.sample_parameters()\n        times = np.arange(0.0, 10.0, 0.05)\n        wavelengths = np.arange(1000.0, 2000.0, 5.0)\n        _ = model.evaluate(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_and_evaluate_step_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4da228a3ca80d938c7c941651e4da5e7ebfffc1f1473459615eb0cce2651205f",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_evaluate_static_source": {
        "code": "class TimeSuite:\n    def time_make_evaluate_static_source(self):\n        \"\"\"Time creating and querying a static source model.\"\"\"\n        source1 = StaticSource(brightness=100.0, node_label=\"my_static_source\")\n        state = source1.sample_parameters(num_samples=1000)\n    \n        times = np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n        wavelengths = np.array([1000.0, 2000.0, 3000.0, 4000.0])\n        _ = source1.evaluate(times, wavelengths, state)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_evaluate_static_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3cec1bd0368f30cc16f3ee0967eb02af78341b16bc66bb7db2b653b4bc979e26",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_new_salt3_model": {
        "code": "class TimeSuite:\n    def time_make_new_salt3_model(self):\n        \"\"\"Time creating a new SALT3 model.\"\"\"\n        _ = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_new_salt3_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8bf14982ac72dd15511fe96fc3f579c0db53ec3aa5a753f8b98ca5a8ebc2c694",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_simple_linear_wavelength_source": {
        "code": "class TimeSuite:\n    def time_make_simple_linear_wavelength_source(self):\n        \"\"\"Time creating a simple LinearWavelengthSource.\"\"\"\n        _ = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_simple_linear_wavelength_source",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "93bb937ea52524f78a34dea88772ed62daaf195fed67de939ed4936bef7b6e1b",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_make_x1_from_hostmass": {
        "code": "class TimeSuite:\n    def time_make_x1_from_hostmass(self):\n        \"\"\"Time the creation of the X1 function.\"\"\"\n        _ = HostmassX1Func(self.hostmass)\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_make_x1_from_hostmass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6142439630c0c164dea584019721a6dbd536834d2a5e09f4151aab44c5bd5615",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_sample_x0_from_distmod": {
        "code": "class TimeSuite:\n    def time_sample_x0_from_distmod(self):\n        \"\"\"Time the computation of the X0 function.\"\"\"\n        _ = self.x0_func.sample_parameters()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_sample_x0_from_distmod",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8e2ad8ce53fbf23e119f367a93ff4d5eac49cb56e34f609e4ca6fd1339916496",
        "warmup_time": -1
    },
    "benchmarks.TimeSuite.time_sample_x1_from_hostmass": {
        "code": "class TimeSuite:\n    def time_sample_x1_from_hostmass(self):\n        \"\"\"Time the computation of the X1 function.\"\"\"\n        _ = self.x1_func.sample_parameters()\n\n    def setup(self):\n        \"\"\"Set up items that will be used in multiple tests.\"\"\"\n        # Preload the passbands for tests that use them.\n        self.passbands = _load_test_passbands()\n    \n        # Create a model we can use in tests.\n        self.redshift = 0.1\n        self.hostmass = 8.0\n        self.distmod_func = DistModFromRedshift(self.redshift, H0=73.0, Omega_m=0.3)\n        self.x1_func = HostmassX1Func(self.hostmass)\n        self.x0_func = X0FromDistMod(\n            distmod=self.distmod_func,\n            x1=self.x1_func,\n            c=0.0,\n            alpha=0.14,\n            beta=3.1,\n            m_abs=-19.3,\n        )\n    \n        self.salt3_model = SncosmoWrapperModel(\n            \"salt3\",\n            t0=0.0,\n            x0=self.x0_func,\n            x1=self.x1_func,\n            c=0.0,\n            ra=0.0,\n            dec=0.0,\n            redshift=self.redshift,\n        )\n    \n        # A simple LinearWavelengthSource that we can use in tests.\n        self.linear_source = LinearWavelengthSource(linear_base=1.0, linear_scale=0.1)\n    \n        # Create samples that we can use in tests.\n        self.times = np.arange(-20.0, 50.0, 0.5)\n        self.wavelengths = self.passbands.waves\n        self.filter_options = [\"LSST_g\", \"LSST_r\"]\n        self.filters = np.array([self.filter_options[i % 2] for i in range(len(self.times))])\n    \n        self.graph_state = self.salt3_model.sample_parameters()\n        self.fluxes = self.salt3_model.evaluate(self.times, self.wavelengths, graph_state=self.graph_state)\n    \n        self.white_noise = WhiteNoise(white_noise_sigma=0.1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSuite.time_sample_x1_from_hostmass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "593b100fbb3f24ccc25a72e99aa0bb1545bd49bd897dd847f985d23759beb7ee",
        "warmup_time": -1
    },
    "version": 2
}